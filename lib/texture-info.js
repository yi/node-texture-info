// Generated by CoffeeScript 1.6.3
(function() {
  var FORMAT_SGF_ANIMATION, SGF_FILE_SIGNATURE, SGF_SERIALISED_BA_SIGNATURE, bytearray, fs, gm, logger, readAniInfoFromSGFFormat, _;

  fs = require('fs');

  gm = require('gm');

  bytearray = require("bytearray");

  logger = require('dev-logger');

  _ = require("underscore");

  SGF_FILE_SIGNATURE = "SGF-asset";

  SGF_SERIALISED_BA_SIGNATURE = 50807718;

  FORMAT_SGF_ANIMATION = "SGF ANIMATION";

  readAniInfoFromSGFFormat = function(pathToImgFile, callback) {
    return fs.readFile(pathToImgFile, function(err, buf) {
      var amfLen, assetFrameNum, assetRects, canvasHeight, canvasWidth, height, i, left, originalRects, regPointX, regPointY, result, signature, top, width, yScroll, _i;
      if (err != null) {
        err = "fail to read file, error:" + err;
        callback(err);
        return;
      }
      signature = bytearray.readUTFBytes(buf, SGF_FILE_SIGNATURE.length, buf.length - SGF_FILE_SIGNATURE.length);
      logger.log("[texture-info::readAniInfoFromSGFFormat] signature:" + signature);
      if (signature !== SGF_FILE_SIGNATURE) {
        err = "verification failed";
        logger.log("[texture-info::readAniInfoFromSGFFormat] " + err);
        callback();
        return;
      }
      buf.position = buf.position - 4 - SGF_FILE_SIGNATURE.length;
      amfLen = bytearray.readUnsignedInt(buf);
      buf.position = buf.position - 4 - amfLen;
      canvasWidth = bytearray.readUnsignedShort(buf);
      canvasHeight = bytearray.readUnsignedShort(buf);
      regPointX = bytearray.readShort(buf);
      regPointY = bytearray.readShort(buf);
      assetFrameNum = bytearray.readUnsignedShort(buf);
      logger.log("[texture-info::readAniInfoFromSGFFormat] amfLen:" + amfLen + ", canvasWidth:" + canvasWidth + ", canvasHeight:" + canvasHeight + ", regPointX:" + regPointX + ", regPointY:" + regPointY);
      assetRects = [];
      originalRects = [];
      yScroll = 0;
      for (i = _i = 0; _i < assetFrameNum; i = _i += 1) {
        left = bytearray.readShort(buf);
        top = bytearray.readShort(buf);
        width = bytearray.readShort(buf);
        height = bytearray.readShort(buf);
        originalRects.push({
          left: left,
          top: top,
          width: width,
          height: height
        });
        assetRects.push({
          left: 0,
          top: yScroll,
          width: width,
          height: height
        });
        yScroll += height;
      }
      result = {
        canvasWidth: canvasWidth,
        canvasHeight: canvasHeight,
        regPointX: regPointX,
        regPointY: regPointY,
        assetFrameNum: assetFrameNum,
        assetRects: assetRects,
        originalRects: originalRects
      };
      callback(null, result);
    });
  };

  exports.check = function(pathToImgFile, callback) {
    if (!fs.existsSync(pathToImgFile)) {
      throw new Error("missing file at " + pathToImgFile);
    }
    if (!_.isFunction(callback)) {
      throw new Error("missing file callback");
    }
    gm(pathToImgFile).identify(function(err, imgInfo) {
      if (err != null) {
        err = "fail to identify image, error:" + err;
        callback(err);
      } else {
        switch (imgInfo.format) {
          case 'PNG':
            return readAniInfoFromSGFFormat(pathToImgFile, function(err, sgfInfo) {
              if (err != null) {
                err = "fail to read sgf info, error:" + err;
                return callback(err);
              } else {
                if (sgfInfo != null) {
                  sgfInfo["sourceImage"] = imgInfo;
                  sgfInfo["format"] = FORMAT_SGF_ANIMATION;
                  return callback(null, sgfInfo);
                } else {
                  return callback(null, imgInfo);
                }
              }
            });
          default:
            callback(null, imgInfo);
        }
      }
    });
  };

  exports.isSGFAnimation = function(pathToImgFile, callback) {
    return exports.check(pathToImgFile, function(err, infoData) {
      console.dir(infoData);
      if (err != null) {
        return callback(err);
      } else {
        return callback(null, infoData["format"] === FORMAT_SGF_ANIMATION);
      }
    });
  };

}).call(this);
